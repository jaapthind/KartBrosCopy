<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ULTRA MONSTER PENALTY PRO 2026</title>
    <style>
        :root { --gold: #facc15; --red: #ef4444; }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', Arial, sans-serif; touch-action: none; user-select: none; }
        
        /* HIGH-END UI STYLES */
        #game-ui { position: absolute; inset: 0; pointer-events: none; z-index: 100; }
        
        .header { position: absolute; top: 30px; left: 30px; display: flex; gap: 20px; }
        .stat-box { background: rgba(0,0,0,0.8); padding: 10px 25px; border-radius: 4px; border-left: 6px solid var(--gold); backdrop-filter: blur(10px); }
        .stat-label { font-size: 12px; text-transform: uppercase; color: #888; letter-spacing: 2px; }
        .stat-value { font-size: 38px; font-weight: 900; color: #fff; display: block; font-style: italic; }

        #power-system { position: absolute; bottom: 60px; left: 50%; transform: translateX(-50%); width: 400px; display: none; }
        .power-bar-bg { width: 100%; height: 12px; background: rgba(255,255,255,0.1); border: 2px solid #fff; border-radius: 20px; overflow: hidden; }
        #power-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #22c55e, var(--gold), var(--red)); transition: width 0.05s linear; }

        #overlay-msg { position: absolute; top: 40%; width: 100%; text-align: center; opacity: 0; transform: scale(0.5); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #overlay-msg.active { opacity: 1; transform: scale(1); }
        .msg-text { font-size: 120px; font-weight: 900; color: var(--gold); text-shadow: 0 10px 30px rgba(0,0,0,0.5); font-style: italic; -webkit-text-stroke: 3px #000; }

        #instructions { position: absolute; bottom: 20px; width: 100%; text-align: center; color: rgba(255,255,255,0.4); font-size: 14px; letter-spacing: 4px; }
    </style>
</head>
<body>

<div id="game-ui">
    <div class="header">
        <div class="stat-box">
            <span class="stat-label">Total Goals</span>
            <span id="score-val" class="stat-value">0</span>
        </div>
        <div class="stat-box">
            <span class="stat-label">Best Streak</span>
            <span id="streak-val" class="stat-value">0</span>
        </div>
    </div>

    <div id="overlay-msg">
        <div id="msg-content" class="msg-text">GOAL!</div>
    </div>

    <div id="power-system">
        <div class="power-bar-bg"><div id="power-fill"></div></div>
    </div>

    <div id="instructions">DRAG BACK & RELEASE TO SHOOT</div>
</div>

<script type="importmap">
{ "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
</script>

<script type="module">
import * as THREE from 'three';

/**
 * ASSET GENERATOR CLASS
 * Handles creation of procedural high-res textures
 */
class AssetFactory {
    static createBallTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 1024; canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#fff'; ctx.fillRect(0,0,1024,1024);
        ctx.fillStyle = '#111';
        const hexSize = 150;
        for(let y=0; y<1024+hexSize; y+=hexSize*1.5) {
            for(let x=0; x<1024+hexSize; x+=hexSize*1.73) {
                const ox = (y/ (hexSize*1.5) % 2 === 0) ? 0 : (hexSize*1.73)/2;
                this.drawHex(ctx, x + ox, y, hexSize * 0.8);
            }
        }
        return new THREE.CanvasTexture(canvas);
    }
    static drawHex(ctx, x, y, size) {
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            ctx.lineTo(x + size * Math.cos(i * Math.PI / 3), y + size * Math.sin(i * Math.PI / 3));
        }
        ctx.closePath(); ctx.fill();
    }
}

/**
 * ENGINE CLASS
 * The main game controller
 */
class PenaltyEngine {
    constructor() {
        this.config = {
            gravity: -0.04,
            dragScale: 0.03,
            goalZ: -45,
            ballStart: new THREE.Vector3(0, 0.6, 25)
        };
        
        this.initCore();
        this.initEnvironment();
        this.initGameObjects();
        this.initPhysics();
        this.initInput();
        
        this.score = 0;
        this.streak = 0;
        this.state = 'IDLE'; // IDLE, AIMING, FLIGHT, RESOLVING
        
        this.animate();
    }

    initCore() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x02110a);
        this.scene.fog = new THREE.FogExp2(0x02110a, 0.012);

        this.camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 1000);
        this.renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(this.renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        this.scene.add(ambient);

        this.sun = new THREE.DirectionalLight(0xffffff, 1.5);
        this.sun.position.set(20, 40, 20);
        this.sun.castShadow = true;
        this.sun.shadow.camera.left = -30; this.sun.shadow.camera.right = 30;
        this.sun.shadow.camera.top = 30; this.sun.shadow.camera.bottom = -30;
        this.sun.shadow.mapSize.set(2048, 2048);
        this.scene.add(this.sun);
    }

    initEnvironment() {
        // High-res Grass
        const grassGeo = new THREE.PlaneGeometry(200, 200);
        const grassMat = new THREE.MeshStandardMaterial({ color: 0x166534 });
        const pitch = new THREE.Mesh(grassGeo, grassMat);
        pitch.rotation.x = -Math.PI/2;
        pitch.receiveShadow = true;
        this.scene.add(pitch);

        // Goal Post System
        const postMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1 });
        const postGeo = new THREE.CylinderGeometry(0.35, 0.35, 10, 20);
        
        this.posts = new THREE.Group();
        const lp = new THREE.Mesh(postGeo, postMat); lp.position.set(-10, 5, this.config.goalZ);
        const rp = new THREE.Mesh(postGeo, postMat); rp.position.set(10, 5, this.config.goalZ);
        const bar = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 20.7, 20), postMat);
        bar.rotation.z = Math.PI/2; bar.position.set(0, 10, this.config.goalZ);
        
        [lp, rp, bar].forEach(m => m.castShadow = true);
        this.posts.add(lp, rp, bar);
        this.scene.add(this.posts);

        // Netting
        const netGeo = new THREE.BoxGeometry(20, 10, 5);
        const netMat = new THREE.MeshPhongMaterial({ color: 0xffffff, wireframe: true, transparent: true, opacity: 0.15 });
        const net = new THREE.Mesh(netGeo, netMat);
        net.position.set(0, 5, this.config.goalZ - 2.5);
        this.scene.add(net);
    }

    initGameObjects() {
        // The Ball
        this.ball = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 64, 64),
            new THREE.MeshStandardMaterial({ map: AssetFactory.createBallTexture(), roughness: 0.4 })
        );
        this.ball.position.copy(this.config.ballStart);
        this.ball.castShadow = true;
        this.scene.add(this.ball);

        // The Goalkeeper (Advanced Capsule)
        this.goalie = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.7, 1.8, 8, 16), new THREE.MeshStandardMaterial({color: 0xef4444}));
        body.position.y = 1.6;
        this.goalie.add(body);
        this.goalie.position.set(0, 0, this.config.goalZ + 1);
        this.scene.add(this.goalie);

        // Precise Aimer Line
        this.aimerLine = new THREE.Line(
            new THREE.BufferGeometry(),
            new THREE.LineBasicMaterial({ color: 0xfacc15, linewidth: 4, transparent: true, opacity: 0.7 })
        );
        this.scene.add(this.aimerLine);
    }

    initPhysics() {
        this.vel = new THREE.Vector3();
        this.rotVel = new THREE.Vector3();
        this.goalieTargetX = 0;
        this.goalieTargetY = 1.6;
    }

    initInput() {
        this.dragStart = new THREE.Vector2();
        const powerFill = document.getElementById('power-fill');
        const powerSys = document.getElementById('power-system');

        const onStart = (x, y) => {
            if(this.state !== 'IDLE') return;
            this.state = 'AIMING';
            this.dragStart.set(x, y);
            powerSys.style.display = 'block';
        };

        const onMove = (x, y) => {
            if(this.state !== 'AIMING') return;
            const dx = this.dragStart.x - x;
            const dy = this.dragStart.y - y;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.4, 100);
            
            // Map Input to Physics Vector
            this.vel.set(dx * 0.003, dy * 0.005, -power * 0.012);
            powerFill.style.width = power + '%';
            
            this.updateTrajectory();
        };

        const onEnd = () => {
            if(this.state !== 'AIMING') return;
            this.state = 'FLIGHT';
            powerSys.style.display = 'none';
            this.aimerLine.geometry.setFromPoints([]);
            
            // AI Prediction
            const timeToGoal = Math.abs((this.config.goalZ - this.ball.position.z) / this.vel.z);
            this.goalieTargetX = THREE.MathUtils.clamp(this.ball.position.x + (this.vel.x * timeToGoal), -9, 9);
            this.goalieTargetY = THREE.MathUtils.clamp(1.6 + (this.vel.y * timeToGoal), 1, 8);
        };

        window.addEventListener('pointerdown', e => onStart(e.clientX, e.clientY));
        window.addEventListener('pointermove', e => onMove(e.clientX, e.clientY));
        window.addEventListener('pointerup', onEnd);
    }

    updateTrajectory() {
        const pts = [];
        let p = this.ball.position.clone();
        let v = this.vel.clone();
        for(let i=0; i<45; i++) {
            pts.push(p.clone());
            p.add(v);
            v.y += this.config.gravity;
            if(p.y < 0.6 || p.z < this.config.goalZ) break;
        }
        this.aimerLine.geometry.setFromPoints(pts);
    }

    handleCollision() {
        // Goalie Collision
        const goaliePos = new THREE.Vector3().copy(this.goalie.position).add(new THREE.Vector3(0, 1.6, 0));
        if(this.ball.position.distanceTo(goaliePos) < 1.8) {
            this.vel.z *= -0.4;
            this.vel.x += (Math.random() - 0.5) * 0.4;
            this.state = 'RESOLVING';
            this.triggerMsg("SAVED!");
        }

        // Post Collision (Simplified box bounds)
        const b = this.ball.position;
        const hitPost = (Math.abs(b.x) > 9.6 && Math.abs(b.x) < 10.4 && b.y < 10 && Math.abs(b.z - this.config.goalZ) < 0.5);
        const hitBar = (Math.abs(b.x) < 10 && Math.abs(b.y - 10) < 0.5 && Math.abs(b.z - this.config.goalZ) < 0.5);
        
        if(hitPost || hitBar) {
            this.vel.z *= -0.5;
            this.vel.y += 0.1;
        }
    }

    triggerMsg(txt) {
        const el = document.getElementById('overlay-msg');
        document.getElementById('msg-content').innerText = txt;
        el.classList.add('active');
        setTimeout(() => this.resetBoard(), 2000);
    }

    resetBoard() {
        this.state = 'IDLE';
        this.ball.position.copy(this.config.ballStart);
        this.vel.set(0,0,0);
        this.goalie.position.set(0, 0, this.config.goalZ + 1);
        this.goalie.rotation.z = 0;
        document.getElementById('overlay-msg').classList.remove('active');
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        if(this.state === 'FLIGHT' || this.state === 'RESOLVING') {
            // Ball Physics
            this.ball.position.add(this.vel);
            this.vel.y += this.config.gravity;
            this.ball.rotation.x += this.vel.z * 0.2;
            this.ball.rotation.z -= this.vel.x * 0.2;

            if(this.ball.position.y < 0.6) {
                this.ball.position.y = 0.6;
                this.vel.y *= -0.3; // Bounce
            }

            // Goalie AI logic
            this.goalie.position.x = THREE.MathUtils.lerp(this.goalie.position.x, this.goalieTargetX, 0.12);
            if(Math.abs(this.goalieTargetX) > 3) {
                this.goalie.rotation.z = THREE.MathUtils.lerp(this.goalie.rotation.z, this.goalieTargetX > 0 ? -1.2 : 1.2, 0.1);
            }

            this.handleCollision();

            // Goal detection
            if(this.ball.position.z < this.config.goalZ && this.state === 'FLIGHT') {
                const isGoal = Math.abs(this.ball.position.x) < 10 && this.ball.position.y < 10 && this.ball.position.y > 0.5;
                this.state = 'RESOLVING';
                if(isGoal) {
                    this.score++;
                    this.streak++;
                    document.getElementById('score-val').innerText = this.score;
                    document.getElementById('streak-val').innerText = this.streak;
                    this.triggerMsg("GOAL!");
                } else {
                    this.streak = 0;
                    document.getElementById('streak-val').innerText = "0";
                    this.triggerMsg("MISS!");
                }
            }

            // Camera follow
            this.camera.position.lerp(new THREE.Vector3(this.ball.position.x * 0.4, 6, this.ball.position.z + 15), 0.1);
        } else {
            this.camera.position.lerp(new THREE.Vector3(0, 7, 40), 0.05);
        }

        this.camera.lookAt(0, 3, this.config.goalZ + 10);
        this.renderer.render(this.scene, this.camera);
    }
}

// Instantiate
new PenaltyEngine();
</script>
</body>
</html>
